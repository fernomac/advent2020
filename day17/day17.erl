-module(day17).
-export([main/0]).
-include_lib("eunit/include/eunit.hrl").

-record(space, {min, max, map = #{}}).

main() ->
  Lines = load("input.txt"),
  io:format("~p~n", [simulate(Lines, 3)]),
  io:format("~p~n", [simulate(Lines, 4)]),
  ok.


% Loads the given input file.

load(Filename) ->
  {ok, File} = file:open(Filename, [read]),
  {ok, Text} = file:read(File, 1024*1024),
  string:split(Text, "\n", all).

% Simulates the boot sequence of the D-dimensional space generated by parsing
% the given lines, returning the number of active elements.

simulate(Lines, D) ->
  Initial = parse(Lines, D),
  Booted  = run(Initial, 6),
  num_active(Booted).  

% Steps the given space forward N times.

run(Space, N) when N > 0  -> run(step(Space), N-1);
run(Space, N) when N == 0 -> Space.

-ifdef(TEST).
simulate_test() ->
  ?assertEqual(112, simulate([".#.", "..#", "###"], 3)),
  ?assertEqual(848, simulate([".#.", "..#", "###"], 4)).
-endif.


num_active(Space) ->
  map_size(Space#space.map).

% Steps the simulation forward one tick, returning the new state.

step(Space) ->
  % We run the simulation for an extra step beyond the furthest active elements we've seen so far,
  % as anything outside of that has no chance of being activated.
  Min = lists:map(fun (X) -> X-1 end, Space#space.min),
  Max = lists:map(fun (X) -> X+1 end, Space#space.max),
  Everywhere = seqvec(Min, Max),

  lists:foldl(fun (Vec, NewSpace) ->
    step(Vec, Space, NewSpace)
  end, Space, Everywhere).

% Steps the simulation forward one tick at the specific position.

step(Vec, OldSpace, NewSpace) ->
  Active = is_active(Vec, OldSpace),
  Count = count_active_neighbors(Vec, OldSpace),
  step(Vec, NewSpace, Active, Count).

count_active_neighbors(Vec, Space) ->
  lists:foldl(fun (Neighbor, Acc) ->
    case is_active(Neighbor, Space) of
      true -> Acc + 1;
      _    -> Acc
    end
  end, 0, neighbors(Vec)).

is_active(Vec, Space) ->
  maps:is_key(Vec, Space#space.map).

step(Vec, Space, Active, Count) ->
  case Active of
    true  -> step_active(Vec, Space, Count);
    false -> step_inactive(Vec, Space, Count)
  end.

step_active(Vec, NewSpace, Count) when not (Count == 2 orelse Count == 3) -> deactivate(Vec, NewSpace);
step_active(_, NewSpace, _)                                               -> NewSpace.

step_inactive(Vec, NewSpace, Count) when Count == 3 -> activate(Vec, NewSpace);
step_inactive(_, NewSpace, _)                       -> NewSpace.

-ifdef(TEST).
step_test() ->
  Space1 = parse([".#.", "..#", "###"], 3),
  Space2 = step(Space1),
  ?assertEqual(11, num_active(Space2)),
  Space3 = step(Space2),
  ?assertEqual(21, num_active(Space3)),
  Space4 = step(Space3),
  ?assertEqual(38, num_active(Space4)).
-endif.



% Parses the given input as a space of dimension D.

parse(Lines, D) ->
  Zero = lists:duplicate(D, 0),
  parse(Lines, D, 0, #space{min = Zero, max = Zero}).

parse([Line | Rest], D, Y, Acc) ->
  NewAcc = parse_line(Line, D, 0, Y, Acc),
  parse(Rest, D, Y+1, NewAcc);
parse([], _, _, Acc) -> Acc.

parse_line([Char | Rest], D, X, Y, Acc) ->
  NewAcc = case Char of
    $# -> 
      Tail = lists:duplicate(D-2, 0),
      activate([X, Y | Tail], Acc);
    $. -> Acc
  end,
  parse_line(Rest, D, X+1, Y, NewAcc);
parse_line([], _, _, _, Acc) -> Acc.

-ifdef(TEST).
parse_3_test() ->
  Space = parse([".#.", "..#", "###"], 3),
  ?assertEqual([0, 0, 0], Space#space.min),
  ?assertEqual([2, 2, 0], Space#space.max),
  ?assertEqual(5, num_active(Space)),
  ?assertEqual(false, is_active([0, 0, 0], Space)),
  ?assertEqual(true,  is_active([1, 0, 0], Space)),
  ?assertEqual(false, is_active([0, 1, 0], Space)),
  ?assertEqual(true,  is_active([2, 1, 0], Space)).

parse_4_test() ->
  Space = parse([".#.", "..#", "###"], 4),
  ?assertEqual([0, 0, 0, 0], Space#space.min),
  ?assertEqual([2, 2, 0, 0], Space#space.max).
-endif.

% Activates the element at the given position.

activate(Vec, Space) ->
  Min = minvec(Vec, Space#space.min),
  Max = maxvec(Vec, Space#space.max),
  Map = (Space#space.map)#{ Vec => true },
  #space{ min = Min, max = Max, map = Map }.

% Deactivates the element at the given position.

deactivate(Vec, Space) ->
  Map = maps:remove(Vec, Space#space.map),
  Space#space{ map = Map }.


% Generates the set of neighbors of the given point.

neighbors(Vec) ->
  Min = lists:duplicate(length(Vec), -1),
  Max = lists:duplicate(length(Vec),  1),
  lists:filtermap(fun (N) ->
    neighbor(Vec, N)
  end, seqvec(Min, Max)).

neighbor(Vec, Off) ->
  case lists:all(fun (X) -> X == 0 end, Off) of
    true -> false;
    _    -> {true, addvec(Vec, Off)}
  end.

-ifdef(TEST).
neighbors_2_test() ->
  ?assertEqual([
    [ 1, 1],
    [ 1, 0],
    [ 1,-1],

    [ 0, 1],
    % [ 0, 0],     not a neighbor of itself
    [ 0,-1],

    [-1, 1],
    [-1, 0],
    [-1,-1]
  ], neighbors([0,0])).

neighbors_3_test() -> ?assertEqual(26, length(neighbors([0,0,0]))).
neighbors_4_test() -> ?assertEqual(80, length(neighbors([0,0,0,0]))).
-endif.

% Adds two vectors together.

addvec(V1,        V2            ) -> addvec(V1, V2, []).
addvec([H1 | R1], [H2 | R2], Acc) -> addvec(R1, R2, [H1+H2 | Acc]);
addvec([],        [],        Acc) -> lists:reverse(Acc).

-ifdef(TEST).
addvec_test() -> ?assertEqual([1,2,3], addvec([0,1,2], [1,1,1])).
-endif.

% Generates a sequence of all positions in the (hyper)cube between V1 and V2.

seqvec(V1, V2) -> seqvec([], V1, V2, []).

seqvec(Prefix, [H1 | R1], [H2 | R2], Acc) ->
  lists:foldl(fun (X, Acc2) ->
    seqvec([X | Prefix], R1, R2, Acc2)
  end, Acc, lists:seq(H1, H2));
seqvec(P, [], [], Acc) -> [lists:reverse(P) | Acc].

-ifdef(TEST).
seqvec_test() ->
  ?assertEqual([
    [ 1, 1],
    [ 1, 0],
    [ 1,-1],
    [ 0, 1],
    [ 0, 0],
    [ 0,-1],
    [-1, 1],
    [-1, 0],
    [-1,-1]
  ], seqvec([-1,-1], [1,1])).
-endif.


% Returns a vector where element N is the minimum of the Nth element of the two inputs.

minvec(V1, V2)                    -> minvec(V1, V2, []).
minvec([H1 | R1], [H2 | R2], Acc) -> minvec(R1, R2, [min(H1, H2) | Acc]);
minvec([], [], Acc)               -> lists:reverse(Acc).

% Returns a vector where element N is the maximum of the Nth element of the two inputs.

maxvec(V1, V2)                    -> maxvec(V1, V2, []).
maxvec([H1 | R1], [H2 | R2], Acc) -> maxvec(R1, R2, [max(H1, H2) | Acc]);
maxvec([], [], Acc)               -> lists:reverse(Acc).

-ifdef(TEST).
minvec_test() ->
  ?assertEqual([0, -2, -100], minvec([0, 5, -100], [1, -2, -1])).
maxvec_test() ->
  ?assertEqual([1, 5, -1], maxvec([0, 5, -100], [1, -2, -1])).
-endif.
